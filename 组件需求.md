# 分布式消息中间件统一接入组件设计需求

## 背景与目标

设计一个统一的分布式消息中间件接入组件，能够支持市面上主流消息队列（如RocketMQ、Kafka、RabbitMQ、Pulsar等），提供标准化的配置、生产者和消费者接口，并支持动态加载和热更新。该组件需要充分考虑性能、可扩展性和可监控性。

## 技术需求

### 1. 核心模块消息队列配置抽象

- **配置类设计**
    - 包含消息队列的基本配置属性和通用属性
    - 兼容RocketMQ、Kafka、RabbitMQ、Pulsar等主流消息队列
    - 支持特性配置，允许具体消息队列扩展特性配置

- **多源多集群配置**
    - 程序支持同时配置多种消息队列和多个集群，同时生效，格式如下示例：
      ```yaml
      message-queue:
          enabled-types: KAFKA, ROCKETMQ
          default-cluster: primary
          ROCKETMQ:
              - primay:
                  cluster: primay
                  server: 127.0.0.1:12345
      ```
    - 可通过消息队列类型、集群名、配置列表进行配置
    - 支持yaml、properties、注解等配置方式
    - 能够根据注解属性或默认集群选择当前连接的消息队列服务配置

- **配置处理**
    - 通过后置处理器进行配置校验和预处理
    - 当接口或注解有自定义配置时，进行合并处理，以自定义为准
    - 能够扩展处理成消息队列子模块需要的类型

- **动态配置**
    - 支持配置动态加载与热更新

- **扩展性**
    - 支持SPI扩展，子类实现需注册到Spring容器

### 2. 生产者接口抽象

- **IProducer接口**
    - 由具体消息队列子模块实现
    - 用户可通过配置进行实例化

- **功能支持**
    - 支持同步/异步发送
    - 支持批量发送
    - 支持延迟消息
    - 支持事务消息
    - 支持广播/点对点等能力
    - 部分能力可通过配置指定
    - 根据具体消息队列类型可扩展特性能力

- **注解支持**
    - 实现`@Producer`注解
    - 支持类/方法级别的消息发送端点自动注册
    - 被注解的方法需返回`MessageResult`或其子类
    - 将`MessageResult`中的`List<Message>`转换为对应消息队列的消息体并发送
    - 结果设置到`MessageResult`的`Future<? extends SendResult>`中

- **多生产者支持**
    - 支持`@Producers(value = {Producer.class})`注解
    - 支持配置优先级
    - 结果封装到`CompositeMessageResult`中，展示每个消息队列发送结果

- **批量处理**
    - 批量发送需在`MessageResult`中展示每条消息的结果
    - 根据事务等配置进行设计

- **处理机制**
    - 通过后置处理器处理`@Producer`注解的类/方法
    - 为其生成代理
    - 通过`IMessageSender.send(MessageResult, MessageQueueProperties等参数)`发送消息
    - 通过SPI扩展消息队列子模块实现具体发送逻辑

- **扩展注册**
    - SPI扩展的子类实现需注册到Spring容器

- **表达式支持**
    - 注解参数支持动态表达式（SpEL）配置

### 3. 消费者接口抽象

- **IConsumer接口**
    - 由具体消息队列子模块实现
    - 用户可通过配置进行实例化

- **通用接口**
    - 定义消息队列消费通用接口
    - 由子模块扩展特性功能

- **注解支持**
    - 实现`@MessageQueueListener`注解
    - 支持类/方法级别的消息监听端点自动注册
    - 被注解的方法需满足对应参数条件即可进行消费
    - 参考spring-kafka、spring-pulsar的实现支持listener注册到容器

- **多消费者支持**
    - 支持`@MessageQueueListeners(value = {MessageQueueListener.class})`注解
    - 支持配置优先级
    - 结果分别作为参数调用被注解方法

- **处理机制**
    - 通过后置处理器处理`@MessageQueueListener`注解的类/方法
    - 参考KafkaListener的设计

- **表达式与实例化**
    - 注解参数支持动态表达式（SpEL）配置
    - 注解能像`@Service`的方式实例化，无需额外添加组件注解如`@Component`

### 4. 用户使用

- **扩展开发**
    - 用户根据核心模块提供的接口和SPI进行扩展开发

- **配置使用**
    - 用户配置已实现的消息队列对应的配置即可使用
    - 支持各种消息队列的扩展

### 5. 模块化架构要求

- **核心模块**
    - 提供标准接口与注解规范
    - 提供Spring生命周期管理

- **依赖隔离**
    - 各MQ实现模块保持编译时依赖隔离

- **动态加载**
    - 运行时动态加载机制需避免类冲突

- **监控与追踪**
    - 提供跨MQ协议的监控指标统一采集接口
    - 支持链路追踪

### 6. 关键技术选型

- **基础框架**
    - 基于Spring全家桶、SpringBoot框架最新版

- **配置绑定**
    - 使用ConfigurationProperties进行配置绑定
    - 可采用更优的技术方案

- **注解解析**
    - 采用BeanPostProcessor实现注解解析
    - @Import等方式进行处理器注入

- **代理实现**
    - 深度使用Spring代理AOP工具
    - 避免直接使用AspectJ等浅显技术

- **代码风格**
    - 参考nacos、dubbo、spring等项目

- **框架设计**
    - 参考spring-kafka、spring-pulsar等

### 7. 参考范式

- Spring Kafka的@KafkaListener实现机制
- Dubbo的SPI扩展加载机制
- RocketMQ-Spring的自动配置方案
- Micrometer的指标采集抽象

### 8. 质量要求

- **性能**
    - 生产者性能需达到10万QPS（单节点）

- **延迟**
    - 消息投递延迟控制在50ms内（P99）

- **更新速度**
    - 配置热更新支持毫秒级生效

- **可追踪性**
    - 提供消息轨迹追踪能力

### 9. 期望输出(交付产物markdown格式mermaid语法输出)

- 架构设计图（包含核心模块交互关系）
- 关键接口的UML类图（含扩展点设计）
- 注解/接口处理流程的时序图
- 配置加载机制的实现策略
- 消息路由的异常处理方案
- 跨MQ协议的事务协调方案（可选）
- 包/模块分层结构
- 详细代码实现设计

## 实现建议

实现此组件时，建议采用以下策略：

1. **接口分层设计**：明确区分API层、SPI层、实现层
2. **配置动态化**：设计松耦合的配置加载机制
3. **扩展点标准化**：定义清晰的扩展接口与约定
4. **性能优化**：采用池化、批量处理等提升吞吐量
5. **异常处理**：设计统一的异常体系与恢复机制
6. **监控设计**：嵌入式采集指标，避免性能影响

## 交付成果

除了上述期望输出外，交付物应包括：

1. 完整的设计文档
2. 核心组件的实现
3. 至少四种MQ的适配实现
4. 单元测试与集成测试
5. 性能测试报告
6. 使用示例与最佳实践 
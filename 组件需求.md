# 分布式消息中间件统一接入组件设计需求

## 背景与目标

设计一个统一的分布式消息中间件接入组件，能够支持市面上主流消息队列（如RocketMQ、Kafka、RabbitMQ、Pulsar等），提供标准化的配置、生产者和消费者接口，并支持动态加载和热更新。该组件需要充分考虑性能、可扩展性和可监控性。

## 问答尝试

### 1、初始问题

```text
现在需要实现一个通用消息队列组件，能融合定义市面上常用的消息队列的通用配置，并支持扩展实现多种消息队列，具体要求如下：
    1、抽象出生产者(IProducer)、消费者(IConsumer)、消息队列配置(MQProperties)，支持rocketMq、Kafka、rabbitMq、pulsar等拓展，可以使用SPI、代理等等技术也可以找市面上更好的方式。其中配置要求支持多源，如同时存在kafka1、kafka2、rocketmq1/2等。
    2、实现注解方式注册生产者(@Producer)、消费者(@Consumer)、消费监听器(@MessageQueueListener)等，生产者和消费者注解支持类、方法级，支持注解上定义组、主题或队列、指定多源消息队列服务的一个或多个服务。注解的生产者和消费者能像@Service的方式实例化，而无需而外添加组件注解如@Component，扫描到的类只要里面方法满足条件即可作为生产或者消费者的方法，生产者的方法以返回值作为消息推到服务器，消费者以参数的方式消费消息，而监听器作为消费任务如@KafkaListener。
    3、1和2作为组件的core模块，在具体组件模块中实现rocketMq、Kafka、rabbitMq、pulsar等的拓展，应用时可以引用这些具体模块，并用1和2中的接口/注解进行选择使用或者结合使用
    4、技术采用Spring全家桶、SpringBoot框架等以及市面上的先进技术方案，代码风格可以学习nacos、dubbo、Spring等无特别要求，不要使用Aspect这种比较浅层的方式。
请设计出方案，并给出最佳实现，不用因为字数限制而在一个回答中写完，可以通过指令接着回答此问题。
```
### 2、生成提示词

```text
分布式消息中间件统一接入组件设计
技术需求:
1、构建跨MQ协议的通用抽象层，需满足：
	a.抽象生产者接口IProducer需包含同步/异步发送、事务消息、广播/点对点等能力
	b.消费者接口IConsumer需支持推拉模式、消费位点控制等特性
	c.抽象出通用配置、特性配置MQProperties，支持多源配置(如rocketMq、Kafka、rabbitMq、pulsar等市面中常用消息队列)
	d.支持通过SPI机制/自动扫描等方式动态加载不同MQ实现(如rocketMq、Kafka、rabbitMq、pulsar等市面中常用消息队列)
	e.支持同时存在多种队列多台集群的配置，根据使用场景选择
2、注解驱动开发模式需实现：
	a.类/方法级@Producer注解自动注册消息发送端点，以返回值作为消息发送
	b.类/方法级@MessageQueueListener实现消息监听路由，如果是类则方法满足对应参数条件即可进行消费
	c.注解参数需支持动态表达式（SpEL）配置
	d.自动发现机制需兼容Spring原生Bean生命周期
	e.注解的生产者和消费者能像@Service的方式实例化，而无需而外添加组件注解如@Component
3、模块化架构要求：
	a.Core模块提供标准接口与注解规范，及Spring生命周期管理
	b.各MQ实现模块保持编译时依赖隔离
	c.运行时动态加载机制需避免类冲突
	d.提供跨MQ协议的监控指标统一采集接口，链路追踪
4、关键技术选型：
	a.必须基于Spring全家桶、SpringBoot框架最新版
	b.使用ConfigurationProperties进行配置绑定，也可以有更好的技术方案选择
	c.采用BeanPostProcessor实现注解解析
	d.深度使用Spring代理AoP工具，不要直接使用AspectJ这类浅显的技术应用
	e.代码风格可以参考nacos、dubbo、spring等
5、期望输出:（优先采用markdown mermaid语法输出）
	a.架构设计图（包含核心模块交互关系）
	b.关键接口的UML类图（含扩展点设计）
	c.注解处理流程的时序图
	d.配置加载机制的实现策略
	e.消息路由的异常处理方案
	f.跨MQ协议的事务协调方案（可选）
	g.详细代码实现(尽量详细，简单的重复的动作可以只给提示)
6、参考范式(仅供参考):
	a.Spring Kafka的@KafkaListener实现机制
	b.Dubbo的SPI扩展加载机制
	c.RocketMQ-Spring的自动配置方案
	d.Micrometer的指标采集抽象
7、质量要求:
	a.生产者性能需达到10万QPS（单节点）
	b.消息投递延迟控制在50ms内（P99）
	c.配置热更新支持毫秒级生效
	d.提供消息轨迹追踪能力
不用因为字数限制而在一个回答中写完，可以通过指令"继续"接着回答此问题
```

## 技术需求

### 1. 核心模块消息队列配置抽象

- **配置类设计**
    - 包含消息队列的基本配置属性和通用属性
    - 兼容RocketMQ、Kafka、RabbitMQ、Pulsar等主流消息队列
    - 支持特性配置，允许具体消息队列扩展特性配置

- **多源多集群配置**
    - 程序支持同时配置多种消息队列和多个集群，同时生效，格式如下示例：
      ```yaml
      message-queue:
          enabled-types: KAFKA, ROCKETMQ
          default-cluster: primary
          ROCKETMQ:
              - primay:
                  cluster: primay
                  server: 127.0.0.1:12345
      ```
    - 可通过消息队列类型、集群名、配置列表进行配置
    - 支持yaml、properties、注解等配置方式
    - 能够根据注解属性或默认集群选择当前连接的消息队列服务配置

- **配置处理**
    - 通过后置处理器进行配置校验和预处理
    - 当接口或注解有自定义配置时，进行合并处理，以自定义为准
    - 能够扩展处理成消息队列子模块需要的类型

- **动态配置**
    - 支持配置动态加载与热更新

- **扩展性**
    - 支持SPI扩展，子类实现需注册到Spring容器

### 2. 生产者接口抽象

- **IProducer接口**
    - 由具体消息队列子模块实现
    - 用户可通过配置进行实例化

- **功能支持**
    - 支持同步/异步发送
    - 支持批量发送
    - 支持延迟消息
    - 支持事务消息
    - 支持广播/点对点等能力
    - 部分能力可通过配置指定
    - 根据具体消息队列类型可扩展特性能力

- **注解支持**
    - 实现`@Producer`注解
    - 支持类/方法级别的消息发送端点自动注册
    - 被注解的方法需返回`MessageResult`或其子类
    - 将`MessageResult`中的`List<Message>`转换为对应消息队列的消息体并发送
    - 结果设置到`MessageResult`的`Future<? extends SendResult>`中

- **多生产者支持**
    - 支持`@Producers(value = {Producer.class})`注解
    - 支持配置优先级
    - 结果封装到`CompositeMessageResult`中，展示每个消息队列发送结果

- **批量处理**
    - 批量发送需在`MessageResult`中展示每条消息的结果
    - 根据事务等配置进行设计

- **处理机制**
    - 通过后置处理器处理`@Producer`注解的类/方法
    - 为其生成代理
    - 通过`IMessageSender.send(MessageResult, MessageQueueProperties等参数)`发送消息
    - 通过SPI扩展消息队列子模块实现具体发送逻辑

- **扩展注册**
    - SPI扩展的子类实现需注册到Spring容器

- **表达式支持**
    - 注解参数支持动态表达式（SpEL）配置

### 3. 消费者接口抽象

- **IConsumer接口**
    - 由具体消息队列子模块实现
    - 用户可通过配置进行实例化

- **通用接口**
    - 定义消息队列消费通用接口
    - 由子模块扩展特性功能

- **注解支持**
    - 实现`@MessageQueueListener`注解
    - 支持类/方法级别的消息监听端点自动注册
    - 被注解的方法需满足对应参数条件即可进行消费
    - 参考spring-kafka、spring-pulsar的实现支持listener注册到容器

- **多消费者支持**
    - 支持`@MessageQueueListeners(value = {MessageQueueListener.class})`注解
    - 支持配置优先级
    - 结果分别作为参数调用被注解方法

- **处理机制**
    - 通过后置处理器处理`@MessageQueueListener`注解的类/方法
    - 参考KafkaListener的设计

- **表达式与实例化**
    - 注解参数支持动态表达式（SpEL）配置
    - 注解能像`@Service`的方式实例化，无需额外添加组件注解如`@Component`

### 4. 用户使用

- **扩展开发**
    - 用户根据核心模块提供的接口和SPI进行扩展开发

- **配置使用**
    - 用户配置已实现的消息队列对应的配置即可使用
    - 支持各种消息队列的扩展

### 5. 模块化架构要求

- **核心模块**
    - 提供标准接口与注解规范
    - 提供Spring生命周期管理

- **依赖隔离**
    - 各MQ实现模块保持编译时依赖隔离

- **动态加载**
    - 运行时动态加载机制需避免类冲突

- **监控与追踪**
    - 提供跨MQ协议的监控指标统一采集接口
    - 支持链路追踪

### 6. 关键技术选型

- **基础框架**
    - 基于Spring全家桶、SpringBoot框架最新版

- **配置绑定**
    - 使用ConfigurationProperties进行配置绑定
    - 可采用更优的技术方案

- **注解解析**
    - 采用BeanPostProcessor实现注解解析
    - @Import等方式进行处理器注入

- **代理实现**
    - 深度使用Spring代理AOP工具
    - 避免直接使用AspectJ等浅显技术

- **代码风格**
    - 参考nacos、dubbo、spring等项目

- **框架设计**
    - 参考spring-kafka、spring-pulsar等

### 7. 参考范式

- Spring Kafka的@KafkaListener实现机制
- Dubbo的SPI扩展加载机制
- RocketMQ-Spring的自动配置方案
- Micrometer的指标采集抽象

### 8. 质量要求

- **性能**
    - 生产者性能需达到10万QPS（单节点）

- **延迟**
    - 消息投递延迟控制在50ms内（P99）

- **更新速度**
    - 配置热更新支持毫秒级生效

- **可追踪性**
    - 提供消息轨迹追踪能力

### 9. 期望输出(交付产物markdown格式mermaid语法输出)

- 架构设计图（包含核心模块交互关系）
- 关键接口的UML类图（含扩展点设计）
- 注解/接口处理流程的时序图
- 配置加载机制的实现策略
- 消息路由的异常处理方案
- 跨MQ协议的事务协调方案（可选）
- 包/模块分层结构
- 详细代码实现设计

## 实现建议

实现此组件时，建议采用以下策略：

1. **接口分层设计**：明确区分API层、SPI层、实现层
2. **配置动态化**：设计松耦合的配置加载机制
3. **扩展点标准化**：定义清晰的扩展接口与约定
4. **性能优化**：采用池化、批量处理等提升吞吐量
5. **异常处理**：设计统一的异常体系与恢复机制
6. **监控设计**：嵌入式采集指标，避免性能影响

## 交付成果

除了上述期望输出外，交付物应包括：

1. 完整的设计文档
2. 核心组件的实现
3. 至少四种MQ的适配实现
4. 单元测试与集成测试
5. 性能测试报告
6. 使用示例与最佳实践 